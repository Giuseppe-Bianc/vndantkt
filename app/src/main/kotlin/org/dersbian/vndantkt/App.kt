/*
 * This source file was generated by the Gradle 'init' task
 */
package org.dersbian.vndantkt

import VandiorLexer
import VandiorParser
import VandiorParserBaseVisitor
import org.antlr.v4.runtime.*
import org.antlr.v4.runtime.tree.*
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import java.io.BufferedReader
import java.io.InputStreamReader
import java.lang.management.ManagementFactory
import kotlin.math.pow
private val logger: Logger = LoggerFactory.getLogger("org.dersbian.vndantkt.MainKt")

fun IntegerLiteralInteral(internalval: String): Int {
    return when {
        internalval.startsWith("0x") || internalval.startsWith("0X") -> internalval.substring(2).replace("_", "")
            .toInt(16)

        internalval.startsWith("0o") || internalval.startsWith("0O") -> internalval.substring(2).replace("_", "")
            .toInt(8)

        internalval.startsWith("0b") || internalval.startsWith("0B") -> internalval.substring(2).replace("_", "")
            .toInt(2)

        else -> internalval.replace("_", "").toInt()
    }
}

class VandiorParserVisitorImpl : VandiorParserBaseVisitor<Any>() {

    // Visit the 'program' rule
    override fun visitProgram(ctx: VandiorParser.ProgramContext): Any {
        // Extract expressions from the program context.
        val expressions = ctx.expr()

        // Use a more efficient approach to collect results and make it a read-only list.
        return expressions.map { visit(it) }
    }



    // Visit the 'AddSub' rule (addition and subtraction)
    override fun visitAddSub(ctx: VandiorParser.AddSubContext): Any {
        val left = visit(ctx.left) // Visit left expression
        val op = ctx.op.text // Get operator ('+' or '-')
        val right = visit(ctx.right) // Visit right expression

        // Convert both operands to Double
        val leftDouble = if (left is Int) left.toDouble() else left as Double
        val rightDouble = if (right is Int) right.toDouble() else right as Double

        return when (op) {
            "+" -> leftDouble + rightDouble
            "-" -> leftDouble - rightDouble
            else -> throw UnsupportedOperationException("Unknown operator: $op")
        }
    }

    override fun visitPowerExp(ctx: VandiorParser.PowerExpContext): Any {
        val left = visit(ctx.left) // Visit left expression
        val op = ctx.op.text // Get operator ('+' or '-')
        val right = visit(ctx.right) // Visit right expression

        // Convert both operands to Double
        val leftDouble = if (left is Int) left.toDouble() else left as Double
        val rightDouble = if (right is Int) right.toDouble() else right as Double

        return when (op) {
            "^" -> leftDouble.pow(rightDouble)
            else -> throw UnsupportedOperationException("Unknown operator: $op")
        }
    }


    // Visit the 'PriExpression' rule (primary expressions)
    override fun visitPriExpression(ctx: VandiorParser.PriExpressionContext): Any {
        return visit(ctx.primaryExpr()) // Visit the children for primary expressions
    }

    // Visit the 'Paren' rule (parentheses expression)
    override fun visitParen(ctx: VandiorParser.ParenContext): Any? {
        return visit(ctx.expr()) // Visit the expression inside the parentheses
    }

    // Visit the 'MultDiv' rule (multiplication and division)
    override fun visitMultDiv(ctx: VandiorParser.MultDivContext): Any {
        val left = visit(ctx.left) // Visit left expression
        val op = ctx.op.text // Get operator ('*' or '/')
        val right = visit(ctx.right) // Visit right expression
        // Convert both operands to Double
        val leftDouble = if (left is Int) left.toDouble() else left as Double
        val rightDouble = if (right is Int) right.toDouble() else right as Double

        return when (op) {
            "*" -> leftDouble * rightDouble
            "/" -> leftDouble / rightDouble
            else -> throw UnsupportedOperationException("Unknown operator: $op")
        }
    }

    // Visit the 'PrimaryExpr' rule (identifier or literal)
    override fun visitPrimaryExpr(ctx: VandiorParser.PrimaryExprContext): Any {
        return visitChildren(ctx) // Visit the primary expression (identifier or literal)
    }

    // Visit the 'Identifier' rule
    override fun visitIdentifier(ctx: VandiorParser.IdentifierContext): Any {
        return ctx.text // Return the text of the identifier
    }

    // Visit the 'Literal' rule (integer, float, boolean, etc.)
    override fun visitLiteral(ctx: VandiorParser.LiteralContext): Any {
        return when {
            ctx.IntegerLiteral() != null -> {
                val internalval = ctx.IntegerLiteral().text
                IntegerLiteralInteral(internalval)
            } // Integer literal
            ctx.FloatingPointLiteral() != null -> ctx.FloatingPointLiteral().text.toDouble() // Floating-point literal
            ctx.BooleanLiteral() != null -> ctx.BooleanLiteral().text.toBoolean() // Boolean literal
            ctx.CharacterLiteral() != null -> ctx.CharacterLiteral().text.single() // Character literal
            ctx.StringLiteral() != null -> ctx.StringLiteral().text // String literal
            ctx.NullLiteral() != null -> 0.0 // Null literal
            else -> throw IllegalArgumentException("Unknown literal type")
        }
    }
}

/*class VandiorParserTreePrinterVisitorImpl : VandiorParserBaseVisitor<String>() {

    private var indentLevel = 0

    // Helper function to create indentation
    private fun indent(): String {
        return " ".repeat(indentLevel)
    }

    // Visit the 'program' rule
    override fun visitProgram(ctx: VandiorParser.ProgramContext): String {
        val expressions = ctx.expr()
        val result = StringBuilder().apply {
            append("Program:\n")
            indentLevel++

            // Process each expression and add the necessary indentations and newlines
            expressions.forEachIndexed { index, expression ->
                append(indent()).append(visit(expression))
                if (index < expressions.size - 1) {
                    append("\n\n")  // Add a newline after each expression except the last one
                }
            }

            indentLevel--
        }

        return result.toString()
    }


    // Visit the 'AddSub' rule (addition and subtraction)
    override fun visitAddSub(ctx: VandiorParser.AddSubContext): String {
        val left = visit(ctx.left)
        val op = ctx.op.text
        val right = visit(ctx.right)

        return StringBuilder().apply {
            append(indent()).append("AddSub ($op)\n")
            indentLevel++
            append(indent()).append(left).append("\n")
            append(indent()).append(right)
            indentLevel--
        }.toString()
    }

    // Visit the 'AddSub' rule (addition and subtraction)
    override fun visitPowerExp(ctx: VandiorParser.PowerExpContext): String {
        val left = visit(ctx.left)
        val op = ctx.op.text
        val right = visit(ctx.right)

        return StringBuilder().apply {
            append(indent()).append("PowerExp ($op)\n")
            indentLevel++
            append(indent()).append(left).append("\n")
            append(indent()).append(right)
            indentLevel--
        }.toString()
    }

    // Visit the 'PriExpression' rule (primary expressions)
    override fun visitPriExpression(ctx: VandiorParser.PriExpressionContext): String {
        return visit(ctx.primaryExpr())
    }

    // Visit the 'Paren' rule (parentheses expression)
    override fun visitParen(ctx: VandiorParser.ParenContext): String {
        return StringBuilder().apply {
            append(indent()).append("Paren\n")
            indentLevel++
            append(indent()).append(visit(ctx.expr()))
            indentLevel--
        }.toString()
    }


    // Visit the 'MultDiv' rule (multiplication and division)
    override fun visitMultDiv(ctx: VandiorParser.MultDivContext): String {
        val left = visit(ctx.left)
        val op = ctx.op.text
        val right = visit(ctx.right)

        return StringBuilder().apply {
            append(indent()).append("MultDiv ($op)\n")
            indentLevel++
            append(indent()).append(left).append("\n")
            append(indent()).append(right)
            indentLevel--
        }.toString()
    }

    // Visit the 'PrimaryExpr' rule (identifier or literal)
    override fun visitPrimaryExpr(ctx: VandiorParser.PrimaryExprContext): String {
        return visitChildren(ctx)
    }

    // Visit the 'Identifier' rule
    override fun visitIdentifier(ctx: VandiorParser.IdentifierContext): String {
        return indent() + "Identifier: " + ctx.text
    }

    // Visit the 'Literal' rule (integer, float, boolean, etc.)
    override fun visitLiteral(ctx: VandiorParser.LiteralContext): String {
        when {
            ctx.IntegerLiteral() != null -> {
                val internalval = ctx.IntegerLiteral().text
                return "${indent()}IntegerLiteral: ${IntegerLiteralInteral(internalval)}"
            } // Integer literal
            ctx.FloatingPointLiteral() != null -> return "${indent()}FloatingPointLiteral: ${ctx.FloatingPointLiteral().text.toDouble()}"// Floating-point literal
            ctx.BooleanLiteral() != null -> return "${indent()}BooleanLiteral: ${ctx.BooleanLiteral().text.toBoolean()}" // Boolean literal
            ctx.CharacterLiteral() != null -> return "${indent()}CharacterLiteral: ${ctx.CharacterLiteral().text.single()}" // Character literal
            ctx.StringLiteral() != null -> return "${indent()}StringLiteral: ${ctx.StringLiteral().text}" // String literal
            ctx.NullLiteral() != null -> return "${indent()}NullLiteral: null" // Null literal
            else -> throw IllegalArgumentException("Unknown literal type")
        }
    }
}*/


class PrettyPrintVisitor(private val indentLevel: Int = 0) : VandiorParserBaseVisitor<String>() {

    private fun indent(): String = "  ".repeat(indentLevel)

    override fun visitProgram(ctx: VandiorParser.ProgramContext): String {
        val expressions = ctx.expr().joinToString("\n") {
            PrettyPrintVisitor(indentLevel + 1).visit(it)
        }
        return "${indent()}Program:\n$expressions"
    }

    override fun visitAddSub(ctx: VandiorParser.AddSubContext): String {
        val left = PrettyPrintVisitor(indentLevel + 1).visit(ctx.left)
        val right = PrettyPrintVisitor(indentLevel + 1).visit(ctx.right)
        return "${indent()}AddSub (${ctx.op.text}):\n$left\n$right"
    }

    override fun visitPowerExp(ctx: VandiorParser.PowerExpContext): String {
        val left = PrettyPrintVisitor(indentLevel + 1).visit(ctx.left)
        val right = PrettyPrintVisitor(indentLevel + 1).visit(ctx.right)
        return "${indent()}PowerExp (${ctx.op.text}):\n$left\n$right"
    }

    override fun visitMultDiv(ctx: VandiorParser.MultDivContext): String {
        val left = PrettyPrintVisitor(indentLevel + 1).visit(ctx.left)
        val right = PrettyPrintVisitor(indentLevel + 1).visit(ctx.right)
        return "${indent()}MultDiv (${ctx.op.text}):\n$left\n$right"
    }

    override fun visitPriExpression(ctx: VandiorParser.PriExpressionContext): String {
        return "${indent()}PrimaryExpr:\n${PrettyPrintVisitor(indentLevel + 1).visit(ctx.primaryExpr())}"
    }

    override fun visitParen(ctx: VandiorParser.ParenContext): String {
        val inner = PrettyPrintVisitor(indentLevel + 1).visit(ctx.expr())
        return "${indent()}Paren:\n$inner"
    }

    override fun visitPrimaryExpr(ctx: VandiorParser.PrimaryExprContext): String {
        return if (ctx.identifier() != null) {
            PrettyPrintVisitor(indentLevel + 1).visit(ctx.identifier())
        } else {
            PrettyPrintVisitor(indentLevel + 1).visit(ctx.literal())
        }
    }

    override fun visitIdentifier(ctx: VandiorParser.IdentifierContext): String {
        return "${indent()}Identifier: ${ctx.Identifier().text}"
    }

    override fun visitLiteral(ctx: VandiorParser.LiteralContext): String {
        when {
            ctx.IntegerLiteral() != null -> {
                val internalval = ctx.IntegerLiteral().text
                var value = when {
                    internalval.startsWith("0x") || internalval.startsWith("0X") -> internalval.substring(2).replace("_", "").toInt(16)
                    internalval.startsWith("0o") || internalval.startsWith("0O") -> internalval.substring(2).replace("_", "").toInt(8)
                    internalval.startsWith("0b") || internalval.startsWith("0B") -> internalval.substring(2).replace("_", "").toInt(2)
                    else -> internalval.replace("_", "").toInt()
                }
                return "${indent()}IntegerLiteral: $value"
            } // Integer literal
            ctx.FloatingPointLiteral() != null -> return "${indent()}FloatingPointLiteral: ${ctx.FloatingPointLiteral().text.toDouble()}"// Floating-point literal
            ctx.BooleanLiteral() != null ->  return "${indent()}BooleanLiteral: ${ctx.BooleanLiteral().text.toBoolean()}" // Boolean literal
            ctx.CharacterLiteral() != null -> return "${indent()}CharacterLiteral: ${ctx.CharacterLiteral().text.single()}" // Character literal
            ctx.StringLiteral() != null -> return "${indent()}StringLiteral: ${ctx.StringLiteral().text}" // String literal
            ctx.NullLiteral() != null -> return "${indent()}NullLiteral: null" // Null literal
            else -> throw IllegalArgumentException("Unknown literal type")
        }
    }
}


/*
class VandiorPrintableTree(val tree: ParseTree) {
    override fun toString() = treeString(tree, "")

    private fun treeString(node: ParseTree, prefix: String): String {
        if (node is VandiorParser.LiteralContext && node.childCount == 1)
            return visitLiteral(node)
        if (node is VandiorParser.IdentifierContext && node.childCount == 1)
            return visitIdentifier(node)

        if (node is TerminalNode) return visitTerminal(node)
        if (node !is RuleNode) return ""

        val name = VandiorParser.ruleNames[node.ruleContext.ruleIndex]
        val builder = StringBuilder(name)

        for (i in 0 until node.childCount) {
            val atEnd = (i == node.childCount - 1)
            val symbol = if (atEnd) "+--" else "|--"

            val child = node.getChild(i)
            val childSymbol = if (atEnd) "   " else "|   "
            val childStr = treeString(child, "$prefix$childSymbol")

            builder.append("\n$prefix$symbol $childStr")
        }

        return "$builder"
    }


    private fun visitIdentifier(node: VandiorParser.IdentifierContext): String {
        val name = VandiorParser.ruleNames[node.ruleContext.ruleIndex]
        val childStr = visitTerminal(node.getChild(0) as TerminalNode)
        return "$name -- $childStr"
    }

    private fun visitLiteral(node: VandiorParser.LiteralContext): String {
        val name = VandiorParser.ruleNames[node.ruleContext.ruleIndex]
        val childStr = visitTerminal(node.getChild(0) as TerminalNode)
        return "$name -- $childStr"
    }

    private fun visitTerminal(node: TerminalNode): String {
        if(node.symbol.type < 1) return "P'$node'"
        val id = VandiorLexer
            .ruleNames[node.symbol.type - 1]
            .let { if ("T__" in it) 'P' else it }

        return "$id'$node'"
    }
}*/

fun readFileFromResources(filename: String): String {
    val inputStream = object {}.javaClass.getResourceAsStream("/$filename")
        ?: throw IllegalArgumentException("File not found in resources: $filename")

    // Use BufferedReader to read the file line by line
    return BufferedReader(InputStreamReader(inputStream)).use { it.readText() }
}


fun main() {
    System.setProperty(
        "PID",
        ManagementFactory.getRuntimeMXBean().name.split("@".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()[0]
    )
    val input = readFileFromResources("input.vn")
    val inputStream = CharStreams.fromString(input)
    val lexer = VandiorLexer(inputStream)
    val tokens = CommonTokenStream(lexer)

    val parser = VandiorParser(tokens)
    val tree = parser.program()

    //val printableTree = VandiorPrintableTree(tree)
    //println(printableTree)

    val printableTree = PrettyPrintVisitor()
    //println(printableTree)
    //println(tree.toStringTree(parser))
    val st = StopWatch("printableTree")
    st.start()
    val printedAST = printableTree.visit(tree)
    logger.info("\n$printedAST")
    st.stop()
    val st2 = StopWatch("eval")
    st2.start()
    val resultimpl = VandiorParserVisitorImpl()
    val res = resultimpl.visit(tree)
    logger.info("$res")
    st2.stop()
}